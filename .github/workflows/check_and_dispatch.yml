name: ðŸš€ Smart Powershell Module Release Pipeline - PesterTestDiscovery

# ðŸŽ¯ Triggers: Push to master branch (e.g., PR merge)
# ðŸ“‹ Required Repository Variables:
# - UBUNTU_VERSION: Ubuntu runner version (e.g., "ubuntu-22.04")
# ðŸ“‹ Required Repository Secrets:  
# - REPO_DISPATCH_TOKEN: Personal Access Token for cross-repo dispatch

on:
  push:
    branches: [master, main]

env:
  # ðŸŒ Global environment variables for consistency
  RELEASE_AUTHOR: "github-actions[bot]"
  RELEASE_EMAIL: "github-actions[bot]@users.noreply.github.com"
  MODULE_NAME: 'K.PSGallery.PesterTestDiscovery'

jobs:
  validate:
    name: ðŸ” Security & ðŸ§ª Tests
    runs-on: ${{ vars.UBUNTU_VERSION || 'ubuntu-24.04' }}
    outputs:
      test-success: ${{ steps.validation.outputs.test-success }}
      total-tests: ${{ steps.validation.outputs.total-tests }}
      passed-tests: ${{ steps.validation.outputs.passed-tests }}
      failed-tests: ${{ steps.validation.outputs.failed-tests }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ§ª Validate PowerShell Module
        id: validation
        uses: GrexyLoco/K.Actions.PSModuleValidation@v1.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          module-name: ${{ env.MODULE_NAME }}

  release:
    name: ðŸš€ Smart Release
    needs: validate
    runs-on: ${{ vars.UBUNTU_VERSION || 'ubuntu-24.04' }}
    outputs:
      new-version: ${{ steps.version.outputs.newVersion }}
      bump-type: ${{ steps.version.outputs.bumpType }}
      release-created: ${{ steps.version.outputs.bumpType != 'none' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: â¬†ï¸ Analyze next version
        id: version
        uses: GrexyLoco/K.Actions.NextVersion@latest
        with:
          branchName: ${{ github.ref_name }}

      - name: ðŸ›‘ Skip if no changes
        if: steps.version.outputs.bumpType == 'none'
        run: |
          echo "## ðŸ” No Release Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "No version changes detected. Skipping release." >> $GITHUB_STEP_SUMMARY
          echo "â„¹ï¸ **No changes detected** - workflow will exit gracefully" >> $GITHUB_STEP_SUMMARY
          
          echo "## ðŸ” No Release Required"
          echo "No version changes detected. Skipping release."
          echo "â„¹ï¸ Workflow will exit gracefully"

      - name: ðŸ“ Update PowerShell Module Version
        if: steps.version.outputs.bumpType != 'none'
        shell: pwsh
        run: |
          Write-Host "ðŸ”§ Updating PSD1 ModuleVersion..."
          
          # ðŸ“ Summary output
          "## ðŸ“ PowerShell Module Version Update" >> $env:GITHUB_STEP_SUMMARY
          "" >> $env:GITHUB_STEP_SUMMARY
          
          # ðŸ” Find PSD1 files in current directory
          $psd1Files = Get-ChildItem -Filter "*.psd1" -File
          
          if ($psd1Files.Count -eq 0) {
            Write-Host "âš ï¸ No PSD1 files found - skipping version update"
            "âš ï¸ **No PSD1 files found** - skipping version update" >> $env:GITHUB_STEP_SUMMARY
            exit 0
          }
          
          $newVersion = "${{ steps.version.outputs.newVersion }}"
          Write-Host "ðŸ“¦ New version: $newVersion"
          
          "**Target Version:** ``$newVersion``" >> $env:GITHUB_STEP_SUMMARY
          "" >> $env:GITHUB_STEP_SUMMARY
          "### Updated Files:" >> $env:GITHUB_STEP_SUMMARY
          
          foreach ($psd1File in $psd1Files) {
            Write-Host "ðŸ“ Updating: $($psd1File.Name)"
            
            # ðŸ“– Read current content
            $content = Get-Content $psd1File.FullName -Raw
            
            # ðŸ”„ Replace ModuleVersion
            $updatedContent = $content -replace "ModuleVersion\s*=\s*'[^']*'", "ModuleVersion = '$newVersion'"
            
            # âœï¸ Write back
            Set-Content -Path $psd1File.FullName -Value $updatedContent -NoNewline
            
            Write-Host "âœ… Updated $($psd1File.Name) to version $newVersion"
            "- âœ… ``$($psd1File.Name)`` â†’ ``$newVersion``" >> $env:GITHUB_STEP_SUMMARY
          }

      - name: ðŸ’¾ Commit PSD1 version update
        if: steps.version.outputs.bumpType != 'none'
        run: |
          git config user.name "${{ env.RELEASE_AUTHOR }}"
          git config user.email "${{ env.RELEASE_EMAIL }}"
          
          # ðŸ“ Summary header
          echo "## ðŸ’¾ Version Commit" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # ðŸ“‹ Check if there are changes
          if git diff --quiet; then
            echo "â„¹ï¸ No PSD1 changes to commit"
            echo "â„¹ï¸ **No PSD1 changes** to commit" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ“ Committing PSD1 version update..."
            git add "*.psd1"
            git commit -m "ðŸ”– Update module version to ${{ steps.version.outputs.newVersion }}

            Auto-updated by release workflow
            - Bump type: ${{ steps.version.outputs.bumpType }}
            - Triggered by: ${{ github.actor }}"
            
            echo "ðŸ“¤ Pushing version update..."
            git push origin ${{ github.ref_name }}
            echo "âœ… PSD1 version update committed and pushed"
            
            # ðŸ“ Summary output
            echo "âœ… **PSD1 version committed and pushed**" >> $GITHUB_STEP_SUMMARY
            echo "- Version: \`${{ steps.version.outputs.newVersion }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Bump: \`${{ steps.version.outputs.bumpType }}\`" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸ”„ Re-fetch after PSD1 update
        if: steps.version.outputs.bumpType != 'none'
        run: |
          echo "ðŸ”„ Re-fetching repository state after PSD1 update..."
          git fetch origin ${{ github.ref_name }}
          git reset --hard origin/${{ github.ref_name }}
          echo "âœ… Repository state synchronized"

      - name: ðŸ“¦ Create GitHub Release
        if: steps.version.outputs.bumpType != 'none'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # ðŸ“ Summary header
          echo "## ðŸ“¦ GitHub Release Creation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # ðŸŽ¨ Custom release notes template
          VERSION="${{ steps.version.outputs.newVersion }}"
          # ðŸ”§ Fix: Extract MAJOR/MINOR without 'v' prefix
          MAJOR=$(echo "$VERSION" | sed -E 's/^([0-9]+)\..*/\1/')
          MINOR=$(echo "$VERSION" | sed -E 's/^([0-9]+\.[0-9]+)\..*/\1/')
          
          echo "ðŸ” Debug: VERSION=$VERSION, MAJOR=$MAJOR, MINOR=$MINOR"
          
          # Create release notes with enhanced links and date formatting
          RELEASE_DATE=$(date -u '+%B %d, %Y at %H:%M UTC')
          {
            echo "## ðŸŽ‰ Release v$VERSION"
            echo ""
            echo "> **${{ steps.version.outputs.bumpType }}** release â€¢ Released on $RELEASE_DATE"
            echo ""
            echo "### ðŸ“¦ Quick Access Links"
            echo "- ðŸ”— **[ðŸ“¦ PowerShell Gallery](https://www.powershellgallery.com/packages/K.PSGallery.PesterTestDiscovery/$VERSION)** - Install with \`Install-Module\`"
            echo "- ðŸ“ **[ðŸ”§ Source Code](https://github.com/${{ github.repository }})** - View the source"
            echo "- ðŸ·ï¸ **[ðŸŽ¯ This Release](https://github.com/${{ github.repository }}/releases/tag/v$VERSION)** - Release details"
            echo "- ðŸ“‹ **[ðŸ“š All Releases](https://github.com/${{ github.repository }}/releases)** - Version history"
            echo "- ðŸ”„ **[âš™ï¸ GitHub Actions](https://github.com/${{ github.repository }}/actions)** - Build pipeline"
            echo ""
            echo "### ðŸš€ Installation & Usage"
            echo '```powershell'
            echo "# Install from PowerShell Gallery"
            echo "Install-Module -Name K.PSGallery.PesterTestDiscovery -RequiredVersion $VERSION"
            echo ""
            echo "# Or install latest version"
            echo "Install-Module -Name K.PSGallery.PesterTestDiscovery"
            echo '```'
            echo ""
            echo '```yaml'
            echo "# For GitHub Actions workflows:"
            echo "uses: GrexyLoco/K.Actions.PSModuleValidation@v$VERSION"
            echo '```'
            echo ""
            echo "### ðŸ·ï¸ Version Tags (Auto-Updated)"
            echo "| Tag | Purpose | Points to | Auto-Updates |"
            echo "|-----|---------|-----------|--------------|"
            echo "| \`@latest\` | Always newest | \`v$VERSION\` | âœ… Every release |"
            echo "| \`@v$VERSION\` | This exact version | \`v$VERSION\` | âŒ Pinned forever |"
            echo "| \`@v$MAJOR\` | Major version line | \`v$VERSION\` | âœ… Minor + Patch |"
            echo "| \`@v$MINOR\` | Minor version line | \`v$VERSION\` | âœ… Patch only |"
            echo ""
            echo "### ðŸ”„ PowerShell Gallery"
            echo "This module will be automatically published to [PowerShell Gallery](https://www.powershellgallery.com/packages/K.PSGallery.PesterTestDiscovery) within minutes."
            echo ""
            echo "---"
            echo "*Generated by [K.Actions.NextVersion](https://github.com/GrexyLoco/K.Actions.NextVersion)*"
          } > release_notes.md
          
          # ðŸ“¦ Smart GitHub Release creation
          RELEASE_TAG="v${{ steps.version.outputs.newVersion }}"
          VERSION="${{ steps.version.outputs.newVersion }}"
          
          # ðŸ” Check if this is a prerelease (alpha, beta, rc)
          IS_PRERELEASE="false"
          if [[ "$VERSION" =~ (alpha|beta|rc|preview|pre) ]]; then
            IS_PRERELEASE="true"
            echo "ðŸ§ª Detected prerelease version: $VERSION"
            echo "ðŸ§ª **Prerelease detected:** \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ Detected stable release: $VERSION"
            echo "ðŸš€ **Stable release:** \`$VERSION\`" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "ðŸ“¦ Creating GitHub Release $RELEASE_TAG..."
          
          # ðŸ”§ Robust handling for duplicate releases (delete and recreate if exists)
          if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            echo "âš ï¸ Release $RELEASE_TAG already exists - deleting and recreating!"
            echo "ðŸ—‘ï¸ **Deleting existing release** (duplicate protection)" >> $GITHUB_STEP_SUMMARY
            
            # ðŸ—‘ï¸ Delete existing release (without tag cleanup to avoid reference errors)
            gh release delete "$RELEASE_TAG" --yes 2>/dev/null || true
            echo "âœ… Existing release deleted"
            
            # ðŸ·ï¸ Check if tag exists and delete it separately if needed
            if git tag -l | grep -q "^$RELEASE_TAG$"; then
              echo "ðŸ·ï¸ Deleting existing tag $RELEASE_TAG..."
              git tag -d "$RELEASE_TAG" 2>/dev/null || true
              git push origin --delete "$RELEASE_TAG" 2>/dev/null || true
              echo "âœ… Tag cleanup completed"
            fi
            
            # ðŸ”„ Wait a moment for GitHub API
            sleep 3
          else
            echo "âœ… No existing release found - proceeding with creation"
          fi
          
          # ðŸ“¦ Create release as DRAFT first (safe, reversible)
          echo "ðŸŽ¯ **NEW STRATEGY**: Draft â†’ Smart Tags â†’ Publish + Latest"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ¯ **Strategy**: Draft â†’ Smart Tags â†’ Publish + Latest" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            echo "ðŸ§ª Creating prerelease as DRAFT...."
            
            # ðŸ›¡ï¸ Create as draft first
            echo "ðŸ” Attempting to create draft prerelease with: gh release create '$RELEASE_TAG' --title 'ðŸ§ª Prerelease $RELEASE_TAG' --notes-file release_notes.md --generate-notes --prerelease --draft"
            
            if gh release create "$RELEASE_TAG" \
              --title "ðŸ§ª Prerelease $RELEASE_TAG" \
              --notes-file release_notes.md \
              --generate-notes \
              --prerelease \
              --draft; then
              echo "ðŸ§ª **Created draft prerelease:** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
              echo "âœ… Draft prerelease created successfully!"
              echo "RELEASE_CREATED=true" >> $GITHUB_ENV
            else
              RELEASE_EXIT_CODE=$?
              echo "âš ï¸ Draft release creation failed with exit code: $RELEASE_EXIT_CODE"
              echo "ðŸ” Checking if release was actually created..."
              
              # Check if release exists despite the error
              if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
                echo "âœ… Release actually exists! This was likely a non-critical error."
                echo "ðŸ§ª **Draft prerelease created (with warnings):** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
                echo "RELEASE_CREATED=true" >> $GITHUB_ENV
              else
                echo "âŒ Release truly failed to be created"
                echo "âš ï¸ **Release creation failed** - workflow continues" >> $GITHUB_STEP_SUMMARY
                echo "RELEASE_CREATED=false" >> $GITHUB_ENV
              fi
            fi
          else
            echo "ðŸš€ Creating stable release as DRAFT..."
            
            # ðŸ›¡ï¸ Create as draft first  
            echo "ðŸ” Attempting to create draft release with: gh release create '$RELEASE_TAG' --title 'ðŸš€ Release $RELEASE_TAG' --notes-file release_notes.md --generate-notes --draft"
            
            if gh release create "$RELEASE_TAG" \
              --title "ðŸš€ Release $RELEASE_TAG" \
              --notes-file release_notes.md \
              --generate-notes \
              --draft; then
              echo "ðŸš€ **Created draft release:** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
              echo "âœ… Draft release created successfully!"
              echo "RELEASE_CREATED=true" >> $GITHUB_ENV
            else
              RELEASE_EXIT_CODE=$?
              echo "âš ï¸ Release creation failed with exit code: $RELEASE_EXIT_CODE"
              echo "ðŸ” Checking if release was actually created..."
              
              # Check if release exists despite the error
              if gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
                echo "âœ… Release actually exists! This was likely a non-critical error."
                echo "ðŸš€ **Release created (with warnings):** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
              else
                echo "âŒ Release truly failed to be created"
                echo "âš ï¸ **Release creation failed** - workflow continues" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          fi
          
          echo "âœ… Release handling completed (creation or fallback)!"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… **Release created successfully!**" >> $GITHUB_STEP_SUMMARY

      - name: ðŸ·ï¸ Create smart tags  
        if: steps.version.outputs.bumpType != 'none'
        run: |
          git config user.name "${{ env.RELEASE_AUTHOR }}"
          git config user.email "${{ env.RELEASE_EMAIL }}"
          
          # ðŸ“ Summary header
          echo "## ðŸ·ï¸ Smart Tag Management" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          NEW_TAG="v${{ steps.version.outputs.newVersion }}"
          MAJOR=$(echo "$NEW_TAG" | sed -E 's/^v([0-9]+)\..*/\1/')
          MINOR=$(echo "$NEW_TAG" | sed -E 's/^v[0-9]+\.([0-9]+)\..*/\1/')
          
          # ðŸ” MEGA DEBUG OUTPUT
          echo "ðŸ” === SMART TAG DEBUG START ==="
          echo "ðŸ” NEW_TAG='$NEW_TAG'"
          echo "ðŸ” MAJOR='$MAJOR'"  
          echo "ðŸ” MINOR='$MINOR'"
          echo "ðŸ” newVersion='${{ steps.version.outputs.newVersion }}'"
          echo "ðŸ” bumpType='${{ steps.version.outputs.bumpType }}'"
          echo "ðŸ” Current HEAD commit: $(git rev-parse HEAD)"
          echo "ðŸ” Current branch: $(git branch --show-current)"
          echo "ðŸ” Existing tags on current commit:"
          git tag --points-at HEAD || echo "ðŸ” No tags on HEAD"
          
          # ðŸ” Enhanced tag fetching with detailed debugging
          echo "ðŸ” === TAG FETCH DEBUGGING ==="
          echo "ðŸ” Local tags before fetch:"
          git tag -l | sort -V || echo "ðŸ” No local tags found"
          
          echo "ðŸ” Fetching all tags from remote (with detailed output)..."
          # First, let's see what remote tags exist
          echo "ðŸ” Remote tags available:"
          git ls-remote --tags origin | head -10 || echo "ðŸ” No remote tags found"
          
          echo "ðŸ” Attempting git fetch --tags..."
          if git fetch --tags 2>&1; then
            echo "ðŸ” âœ… Tag fetch completed successfully"
          else
            FETCH_EXIT_CODE=$?
            echo "ðŸ” âš ï¸ Tag fetch failed with exit code: $FETCH_EXIT_CODE"
            echo "ðŸ” Using --force to handle Smart Tag conflicts (expected behavior)..."
            
            if git fetch --tags --force 2>&1; then
              echo "ðŸ” âœ… Force tag fetch completed successfully"
            else
              echo "ðŸ” âŒ Even force fetch failed - continuing anyway..."
            fi
          fi
          
          echo "ðŸ” All tags after fetch attempt:"
          git tag -l | sort -V | head -10 || echo "ðŸ” No tags found after fetch"
          
          # Enhanced conflict detection with summary reporting
          echo "ðŸ” Analyzing Smart Tag movements:"
          TAG_MOVEMENTS=""
          for tag in "v1" "v1.1" "latest"; do
            if git tag -l "$tag" | grep -q "$tag"; then
              LOCAL_COMMIT=$(git rev-parse "$tag" 2>/dev/null || echo "unknown")
              echo "ðŸ” Local tag '$tag' points to: $LOCAL_COMMIT"
              
              # Check if remote has this tag
              if git ls-remote --exit-code --tags origin "refs/tags/$tag" >/dev/null 2>&1; then
                REMOTE_COMMIT=$(git ls-remote --tags origin "refs/tags/$tag" | cut -f1)
                echo "ðŸ” Remote tag '$tag' points to: $REMOTE_COMMIT"
                
                if [[ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]]; then
                  echo "ðŸ” âœ… SMART TAG MOVED: '$tag' was updated from $LOCAL_COMMIT to $REMOTE_COMMIT"
                  # Extract commit short hashes for summary
                  LOCAL_SHORT=$(echo "$LOCAL_COMMIT" | cut -c1-8)
                  REMOTE_SHORT=$(echo "$REMOTE_COMMIT" | cut -c1-8)
                  TAG_MOVEMENTS="${TAG_MOVEMENTS}- ðŸ”„ \`$tag\`: \`$LOCAL_SHORT\` â†’ \`$REMOTE_SHORT\`"$'\n'
                else
                  echo "ðŸ” âœ… Tag '$tag' unchanged (both point to same commit)"
                fi
              else
                echo "ðŸ” Remote tag '$tag' does not exist"
              fi
            else
              echo "ðŸ” Local tag '$tag' does not exist"
            fi
          done
          echo "ðŸ” === TAG FETCH DEBUGGING END ==="
          
          # Add tag movements to summary with enhanced parallel display
          if [[ -n "$TAG_MOVEMENTS" ]]; then
            echo "### ðŸ”„ Smart Tag Updates (Parallel View):" >> $GITHUB_STEP_SUMMARY
            echo "$TAG_MOVEMENTS" >> $GITHUB_STEP_SUMMARY
            echo "âœ… **All tags synchronized** - pointing to \`v${{ steps.version.outputs.newVersion }}\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Enhanced parallel tag status display with current version info
          echo "### ðŸ·ï¸ Live Tag Status (Current Repository State):" >> $GITHUB_STEP_SUMMARY
          echo "| Tag | Current Target | Purpose | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|----------------|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| \`v${{ steps.version.outputs.newVersion }}\` | \`$(git rev-parse HEAD | cut -c1-8)\` | Exact version | âœ… New |" >> $GITHUB_STEP_SUMMARY
          echo "| \`v$MAJOR\` | \`v${{ steps.version.outputs.newVersion }}\` | Auto-updated major | ðŸ”„ Updated |" >> $GITHUB_STEP_SUMMARY
          echo "| \`v$MAJOR.$MINOR\` | \`v${{ steps.version.outputs.newVersion }}\` | Auto-updated minor | ðŸ”„ Updated |" >> $GITHUB_STEP_SUMMARY
          echo "| \`latest\` | \`v${{ steps.version.outputs.newVersion }}\` | Always newest | ðŸ”„ Updated |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Sync Status:** ðŸ”„ All tags synchronized with remote repository" >> $GITHUB_STEP_SUMMARY
          
          # ðŸ”§ Ensure base tag exists (fallback if release creation failed)
          if ! git tag -l "$NEW_TAG" | grep -q "$NEW_TAG"; then
            echo "ðŸ” âš ï¸ Base tag $NEW_TAG not found - creating locally"
            git tag "$NEW_TAG" HEAD
            echo "ðŸ” âœ… Created local tag $NEW_TAG on HEAD"
          else
            echo "ðŸ” âœ… Base tag $NEW_TAG exists"
          fi
          
          echo "ðŸ” === SMART TAG DEBUG END ==="
          
          echo "## ðŸ·ï¸ Smart Tag Management"
          echo "**Base Version:** \`$NEW_TAG\` (created by GitHub Release)"
          echo "**Bump Type:** \`${{ steps.version.outputs.bumpType }}\`"
          echo "**Repository:** All tags will be synchronized to remote"
          
          echo "**Base Version:** \`$NEW_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** \`${{ steps.version.outputs.bumpType }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Repository Sync:** ðŸ”„ All tags synchronized to remote repository" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** \`${{ steps.version.outputs.currentVersion }}\` â†’ **New Version:** \`${{ steps.version.outputs.newVersion }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Smart tag updates based on bump type (only for stable releases)
          VERSION="${{ steps.version.outputs.newVersion }}"
          echo "ðŸ” VERSION (again)='$VERSION'"
          echo "ðŸ” Checking if prerelease...."
          
          # Initialize smart tags success tracking
          SMART_TAGS_SUCCESS="true"
          
          if [[ ! "$VERSION" =~ (alpha|beta|rc|preview|pre) ]]; then
            echo "ðŸ” âœ… STABLE RELEASE - proceeding with smart tags"
            MINOR_TAG="v$MAJOR.$MINOR"
            MAJOR_TAG="v$MAJOR"
            
            echo "ðŸ” MINOR_TAG='$MINOR_TAG'"
            echo "ðŸ” MAJOR_TAG='$MAJOR_TAG'"
            echo "ðŸ” About to enter case statement..."
            
            echo "### ðŸŽ¯ Tags Updated:" >> $GITHUB_STEP_SUMMARY
            
            echo "ðŸ” Case statement input: '${{ steps.version.outputs.bumpType }}'"
            case "${{ steps.version.outputs.bumpType }}" in
              "patch")
                echo "ðŸ” ðŸŽ¯ ENTERED PATCH CASE"
                
                # ðŸ—‘ï¸ Delete existing moving tags first (clean slate)
                echo "ðŸ” Deleting existing moving tags..."
                git push --delete origin "$MINOR_TAG" 2>/dev/null || echo "ðŸ” $MINOR_TAG doesn't exist remotely"
                git push --delete origin "$MAJOR_TAG" 2>/dev/null || echo "ðŸ” $MAJOR_TAG doesn't exist remotely"
                git tag -d "$MINOR_TAG" 2>/dev/null || echo "ðŸ” $MINOR_TAG doesn't exist locally"
                git tag -d "$MAJOR_TAG" 2>/dev/null || echo "ðŸ” $MAJOR_TAG doesn't exist locally"
                
                # ðŸ†• Create fresh tags pointing to new version
                echo "ðŸ” Executing: git tag '$MINOR_TAG' '$NEW_TAG'"
                git tag "$MINOR_TAG" "$NEW_TAG"
                TAG_RESULT1=$?
                echo "ðŸ” git tag result: $TAG_RESULT1"
                
                echo "ðŸ” Executing: git push origin '$MINOR_TAG'"
                git push origin "$MINOR_TAG"
                PUSH_RESULT1=$?
                echo "ðŸ” git push result: $PUSH_RESULT1"
                
                echo "ðŸ” Executing: git tag '$MAJOR_TAG' '$NEW_TAG'"
                git tag "$MAJOR_TAG" "$NEW_TAG"
                TAG_RESULT2=$?
                echo "ðŸ” git tag result: $TAG_RESULT2"
                
                echo "ðŸ” Executing: git push origin '$MAJOR_TAG'"
                git push origin "$MAJOR_TAG"
                PUSH_RESULT2=$?
                echo "ðŸ” git push result: $PUSH_RESULT2"
                
                # Check if any tag operations failed
                if [[ $TAG_RESULT1 -ne 0 || $PUSH_RESULT1 -ne 0 || $TAG_RESULT2 -ne 0 || $PUSH_RESULT2 -ne 0 ]]; then
                  echo "âš ï¸ Some tag operations failed!"
                  SMART_TAGS_SUCCESS="false"
                fi
                
                echo "**Updated:** \`$MINOR_TAG\` + \`$MAJOR_TAG\`"
                echo "- âœ… Updated: \`$MINOR_TAG\` â†’ \`$NEW_TAG\` (exit: $TAG_RESULT1/$PUSH_RESULT1)" >> $GITHUB_STEP_SUMMARY
                echo "- âœ… Updated: \`$MAJOR_TAG\` â†’ \`$NEW_TAG\` (exit: $TAG_RESULT2/$PUSH_RESULT2)" >> $GITHUB_STEP_SUMMARY
                ;;
              "minor") 
                echo "ðŸ” ðŸŽ¯ ENTERED MINOR CASE"
                git tag "$MINOR_TAG" "$NEW_TAG" && git push origin "$MINOR_TAG"
                git tag -f "$MAJOR_TAG" "$NEW_TAG" && git push -f origin "$MAJOR_TAG"
                echo "**Created:** \`$MINOR_TAG\` **Updated:** \`$MAJOR_TAG\`"
                echo "- ðŸ†• Created: \`$MINOR_TAG\` â†’ \`$NEW_TAG\`" >> $GITHUB_STEP_SUMMARY
                echo "- âœ… Updated: \`$MAJOR_TAG\` â†’ \`$NEW_TAG\`" >> $GITHUB_STEP_SUMMARY
                ;;
              "major")
                echo "ðŸ” ðŸŽ¯ ENTERED MAJOR CASE"
                git tag "$MINOR_TAG" "$NEW_TAG" && git push origin "$MINOR_TAG"  
                git tag "$MAJOR_TAG" "$NEW_TAG" && git push origin "$MAJOR_TAG"
                echo "**Created:** \`$MINOR_TAG\` + \`$MAJOR_TAG\`"
                echo "- ðŸ†• Created: \`$MINOR_TAG\` â†’ \`$NEW_TAG\`" >> $GITHUB_STEP_SUMMARY
                echo "- ðŸ†• Created: \`$MAJOR_TAG\` â†’ \`$NEW_TAG\`" >> $GITHUB_STEP_SUMMARY
                ;;
              *)
                echo "ðŸ” âŒ NO CASE MATCHED! bumpType='${{ steps.version.outputs.bumpType }}'"
                echo "ðŸ” âŒ Available cases: patch, minor, major"
                ;;
            esac
            
            echo "ðŸ” Now updating 'latest' tag..."
            # ðŸ—‘ï¸ Delete existing latest tag first (clean slate)
            echo "ðŸ” Deleting existing latest tag..."
            git push --delete origin "latest" 2>/dev/null || echo "ðŸ” latest doesn't exist remotely"
            git tag -d "latest" 2>/dev/null || echo "ðŸ” latest doesn't exist locally"
            
            # ðŸ†• Create fresh latest tag
            git tag "latest" "$NEW_TAG" 
            LATEST_TAG_RESULT=$?
            echo "ðŸ” latest tag result: $LATEST_TAG_RESULT"
            
            git push origin "latest"
            LATEST_PUSH_RESULT=$?
            echo "ðŸ” latest push result: $LATEST_PUSH_RESULT"
            
            # Check if latest tag operations failed
            if [[ $LATEST_TAG_RESULT -ne 0 || $LATEST_PUSH_RESULT -ne 0 ]]; then
              echo "âš ï¸ Latest tag operations failed!"
              SMART_TAGS_SUCCESS="false"
            fi
            
            echo "**Updated:** \`latest\`"
            echo "- âœ… Updated: \`latest\` â†’ \`$NEW_TAG\` (exit: $LATEST_TAG_RESULT/$LATEST_PUSH_RESULT)" >> $GITHUB_STEP_SUMMARY
            
            # Export smart tags success status for next step
            echo "SMART_TAGS_SUCCESS=$SMART_TAGS_SUCCESS" >> $GITHUB_ENV
            echo "ðŸ” Smart Tags Success: $SMART_TAGS_SUCCESS"
          else
            echo "ðŸ” â­ï¸ PRERELEASE DETECTED - skipping smart tags"
            echo "â­ï¸ **Skipping smart tags** (prerelease version)"
            echo "â­ï¸ **Skipped smart tags** (prerelease version)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: ðŸš€ Publish Release (Final Step)
        if: steps.version.outputs.bumpType != 'none'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # ðŸŽ¯ Final step: Publish the draft release with enhanced status
          echo "## ðŸš€ Release Publication Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          RELEASE_TAG="v${{ steps.version.outputs.newVersion }}"
          VERSION="${{ steps.version.outputs.newVersion }}"
          
          # Enhanced release status display
          echo "**Release Target:** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "**Publication Date:** $(date -u '+%B %d, %Y at %H:%M UTC')" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** [${GITHUB_REPOSITORY}](https://github.com/${GITHUB_REPOSITORY})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if we created a release earlier
          if [[ "${RELEASE_CREATED:-false}" == "true" ]]; then
            echo "âœ… Release was created as draft - proceeding with publication..."
            
            # Only proceed if smart tags were successful (or if it's a prerelease)
            if [[ "${SMART_TAGS_SUCCESS:-true}" == "true" || "$VERSION" =~ (alpha|beta|rc|preview|pre) ]]; then
              echo "âœ… Smart tags successful (or prerelease) - proceeding with publication"
            
            # Check if this is a prerelease
            if [[ "$VERSION" =~ (alpha|beta|rc|preview|pre) ]]; then
              echo "ðŸ§ª Publishing prerelease..."
              if gh release edit "$RELEASE_TAG" --draft=false; then
                echo "âœ… Prerelease published successfully!"
                echo "ðŸ§ª **Prerelease published:** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
              else
                echo "âš ï¸ Failed to publish prerelease, but it exists as draft"
                echo "âš ï¸ **Prerelease publication failed** (remains as draft)" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "ðŸš€ Publishing stable release with latest flag..."
              if gh release edit "$RELEASE_TAG" --draft=false --latest; then
                echo "âœ… Stable release published and marked as latest!"
                echo "ðŸš€ **Stable release published and marked latest:** \`$RELEASE_TAG\`" >> $GITHUB_STEP_SUMMARY
              else
                echo "âš ï¸ Failed to publish release or mark as latest"
                # Try just publishing without latest flag
                if gh release edit "$RELEASE_TAG" --draft=false; then
                  echo "âœ… Release published (but latest status unclear)"
                  echo "ðŸš€ **Release published:** \`$RELEASE_TAG\` (latest status unclear)" >> $GITHUB_STEP_SUMMARY
                else
                  echo "âŒ Failed to publish release at all"
                  echo "âŒ **Release publication failed** (remains as draft)" >> $GITHUB_STEP_SUMMARY
                fi
              fi
            fi
            
            # Final verification
            echo "ðŸ” Final release verification:"
            if gh release view "$RELEASE_TAG" --json isDraft,isLatest; then
              echo "âœ… Release verification completed"
            else
              echo "âš ï¸ Release verification failed"
            fi
            
            else
              echo "âŒ Smart tags failed - keeping release as draft for safety"
              echo "âŒ **Release kept as draft** (smart tags failed)" >> $GITHUB_STEP_SUMMARY
              echo "ðŸ”§ **Manual action required**: Fix smart tags, then manually publish release"
            fi
            
          else
            echo "âŒ No release was created in the earlier step - skipping publication"
            echo "âŒ **No release to publish** (creation failed earlier)" >> $GITHUB_STEP_SUMMARY
          fi

  notify:
    name: ðŸ“£ Deploy Notification
    needs: [validate, release]
    if: needs.release.outputs.release-created == 'true' && needs.validate.outputs.test-success == 'true'
    runs-on: ${{ vars.UBUNTU_VERSION || 'ubuntu-24.04' }}
    steps:
      - name: ðŸ“£ Info - Notify deployment pipeline
        run: |
          # ðŸ“ Summary header
          echo "## ðŸ“£ Deployment Notification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## ðŸ“£ Deployment Notification"
          echo "**Target:** K.PSGallery deployment pipeline"
          echo "**Version:** v${{ needs.release.outputs.new-version }}"
          echo "**Bump Type:** ${{ needs.release.outputs.bump-type }}"
          
          # Enhanced summary with direct links
          echo "**Target:** ðŸŽ¯ [K.PSGallery Repository](https://github.com/GrexyLoco/K.PSGallery) deployment" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`v${{ needs.release.outputs.new-version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Bump Type:** \`${{ needs.release.outputs.bump-type }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Quick Links:" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“¦ [PowerShell Gallery Package](https://www.powershellgallery.com/packages/K.PSGallery.PesterTestDiscovery)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”„ [Deployment Pipeline](https://github.com/GrexyLoco/K.PSGallery/actions)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ“‹ [Source Repository](https://github.com/${{ github.repository }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Send repository dispatch with proper error handling
          echo "ðŸš€ Triggering deployment pipeline..."

      - name: Execute - Notify deployment pipeline
        uses: peter-evans/repository-dispatch@v3
        with:
            token: ${{ secrets.REPO_DISPATCH_TOKEN }}
            repository: grexyloco/K.PSGallery
            event-type: publish_module
            client-payload: |
              {
                "repo": "${{ github.repository }}",
                "tag": "v${{ needs.release.outputs.new-version }}",
                "bump_type": "${{ needs.release.outputs.bump-type }}",
                "triggered_by": "${{ github.actor }}",
                "source_url": "https://github.com/${{ github.repository }}",
                "gallery_url": "https://www.powershellgallery.com/packages/K.PSGallery.PesterTestDiscovery/${{ needs.release.outputs.new-version }}"
              }
